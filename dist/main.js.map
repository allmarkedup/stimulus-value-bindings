{"mappings":"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","sources":["src/index.js","src/utils/index.js","src/utils/next-tick.js","src/utils/walk.js","src/use-value-bindings.js","src/scheduler.js","src/mutation-observers/index.js","src/mutation-observers/observe-values.js","src/mutation-observers/observe-tree.js","src/bindings.js","node_modules/dot-prop/index.js","src/bind.js","src/classes.js"],"sourcesContent":["import { nextTick } from \"./utils\";\nimport { useValueBindings } from \"./use-value-bindings\";\n\nexport { useValueBindings, nextTick };\n","import { nextTick } from \"./next-tick\";\nimport { walk } from \"./walk\";\n\nexport { nextTick, walk };\n","let stack = [];\n\nexport function nextTick(callback = () => {}) {\n  queueMicrotask(() => {\n    setTimeout(() => releaseNextTicks());\n  });\n\n  return new Promise((res) => {\n    stack.push(() => {\n      callback();\n      res();\n    });\n  });\n}\n\nfunction releaseNextTicks() {\n  while (stack.length) stack.shift()();\n}\n","export function walk(el, callback) {\n  let skip = false;\n  callback(el, () => (skip = true));\n  if (skip) return;\n\n  let node = el.firstElementChild;\n  while (node) {\n    walk(node, callback, false);\n    node = node.nextElementSibling;\n  }\n}\n","import { queueJob } from \"./scheduler\";\nimport { observeValues, observeTree } from \"./mutation-observers\";\nimport {\n  registerBindings,\n  updateBindings,\n  clearBindings,\n  registerBindingsForNode,\n  deregisterBindingsForNode,\n} from \"./bindings\";\n\nexport const useValueBindings = (controller) => {\n  let initialUpdateHasRun = false;\n\n  const updateBindingsAndNotify = () => {\n    updateBindings(controller, () => {\n      if (typeof controller.bindingsUpdated === \"function\") {\n        controller.bindingsUpdated(!initialUpdateHasRun);\n      }\n    });\n    initialUpdateHasRun = true;\n  };\n\n  const scheduleUpdate = () => queueJob(updateBindingsAndNotify);\n\n  const valuesObserver = observeValues(controller, scheduleUpdate);\n  const treeObserver = observeTree(controller, (addedNodes, removedNodes) => {\n    removedNodes.forEach((node) => deregisterBindingsForNode(controller, node));\n    addedNodes.forEach((node) => registerBindingsForNode(controller, node));\n    treeObserver.runWithoutObservation(updateBindingsAndNotify);\n  });\n\n  registerBindings(controller);\n  scheduleUpdate();\n\n  const disconnect = controller.disconnect;\n  Object.assign(controller, {\n    updateBindings: scheduleUpdate,\n\n    disconnect() {\n      valuesObserver.stop();\n      treeObserver.stop();\n      clearBindings(controller);\n\n      if (typeof disconnect === \"function\") {\n        disconnect.bind(controller)();\n      }\n    },\n  });\n\n  treeObserver.start();\n  valuesObserver.start();\n};\n","let flushPending = false;\nlet flushing = false;\nlet queue = [];\nlet lastFlushedIndex = -1;\n\nexport function queueJob(job) {\n  if (!queue.includes(job)) queue.push(job);\n  queueFlush();\n}\n\nfunction queueFlush() {\n  if (!flushing && !flushPending) {\n    flushPending = true;\n    queueMicrotask(flushJobs);\n  }\n}\n\nexport function flushJobs() {\n  flushPending = false;\n  flushing = true;\n\n  for (let i = 0; i < queue.length; i++) {\n    queue[i]();\n    lastFlushedIndex = i;\n  }\n\n  queue.length = 0;\n  lastFlushedIndex = -1;\n  flushing = false;\n}\n","import { observeValues } from \"./observe-values\";\nimport { observeTree } from \"./observe-tree\";\n\nexport { observeValues, observeTree };\n","export function observeValues(controller, callback) {\n  const values = controller.constructor.values || {};\n\n  let observing = false;\n\n  const changeCallbacks = Object.keys(values).map((key) => {\n    const callbackName = `${key}ValueChanged`;\n    const controllerCallback = controller[callbackName];\n    const monkeyPatchedCallback = function (value, previousValue) {\n      if (observing) {\n        callback(key, value, previousValue, this);\n      }\n      if (typeof controllerCallback === \"function\") {\n        controllerCallback.call(this, value, previousValue);\n      }\n    };\n    return [callbackName, monkeyPatchedCallback.bind(controller)];\n  });\n\n  Object.assign(controller, Object.fromEntries(changeCallbacks));\n\n  return {\n    start() {\n      observing = true;\n    },\n    stop() {\n      observing = false;\n    },\n  };\n}\n","export function observeTree(controller, callback) {\n  let observing = false;\n  const { element } = controller;\n  const filterElementNodes = (nodes) => Array.from(nodes).filter((node) => node.nodeType !== 3);\n\n  const onMutate = (mutationList) => {\n    const removedNodes = [];\n    const addedNodes = [];\n\n    mutationList.forEach((mutation) => {\n      if (mutation.type === \"childList\") {\n        removedNodes.push(...filterElementNodes(mutation.removedNodes));\n        addedNodes.push(...filterElementNodes(mutation.addedNodes));\n      }\n    });\n    if (addedNodes.length || removedNodes.length) {\n      callback(addedNodes, removedNodes);\n    }\n  };\n\n  const observer = new MutationObserver(onMutate);\n\n  return {\n    start() {\n      if (!observing) {\n        observer.observe(element, { childList: true, subtree: true });\n        observing = true;\n      }\n    },\n    stop() {\n      if (observing) {\n        const mutations = observer.takeRecords();\n        if (mutations.length > 0) onMutate(mutations);\n        observer.disconnect();\n        observing = false;\n      }\n    },\n    runWithoutObservation(callback) {\n      this.stop();\n      callback();\n      this.start();\n    },\n  };\n}\n","import { getProperty } from \"dot-prop\";\nimport { bind } from \"./bind\";\nimport { walk } from \"./utils\";\n\nexport function updateBindings(controller, callback) {\n  const bindings = getBindings(controller);\n\n  bindings.forEach((binding) => {\n    let { node, name, path, negated } = binding;\n    if (!controller.element.contains(node)) {\n      // clean up any bindings for elements that have been removed from the DOM\n      bindings.delete(binding);\n    } else {\n      updateBindingsForNode(controller, node, name, path, negated);\n      node.removeAttribute(\"data-cloak\");\n    }\n  });\n\n  if (typeof callback === \"function\") {\n    // Run the callback once all bindings have been updated.\n    callback();\n  }\n}\n\nfunction updateBindingsForNode(controller, node, name, path, negated) {\n  let value = getProperty(controller, path);\n\n  if (typeof value === \"function\") {\n    value = value.bind(controller)(node);\n  }\n\n  bind(node, name, negated ? !value : value);\n}\n\nexport function registerBindings(controller) {\n  if (!bindingsAreInitialized(controller)) {\n    controller.__value_bindings = new Set();\n    registerBindingsForNode(controller, controller.element);\n  }\n}\n\nexport function registerBindingsForNode(controller, rootNode) {\n  const attrPrefix = `data-${controller.identifier}-bind`;\n\n  walk(rootNode, (node) => {\n    Array.from(node.attributes)\n      .filter(({ name }) => name.startsWith(attrPrefix))\n      .forEach((attr) => {\n        let negated = false;\n        let path = attr.value;\n        if (path.startsWith(\"!\")) {\n          negated = true;\n          path = path.replace(\"!\", \"\");\n        }\n        const name = attr.name === attrPrefix ? \"all\" : attr.name.replace(`${attrPrefix}-`, \"\");\n        registerBinding(controller, node, name, path, negated);\n        node.removeAttribute(attr.name);\n      });\n  });\n}\n\nexport function refreshBindings(controller) {\n  clearBindings(controller);\n  registerBindings(controller);\n}\n\nexport function registerBinding(controller, node, name, path, negated) {\n  getBindings(controller).add({ node, name, path, negated });\n}\n\nexport function deregisterBindingsForNode(controller, node) {\n  const bindings = getBindings(controller);\n\n  bindings.forEach((binding) => {\n    if (binding.node === node) {\n      bindings.delete(binding);\n    }\n  });\n}\n\nexport function clearBindings(controller) {\n  controller.__value_bindings?.clear();\n  controller.__value_bindings = new Set();\n}\n\nexport function getBindings(controller) {\n  return controller.__value_bindings;\n}\n\nfunction bindingsAreInitialized(controller) {\n  return controller.__value_bindings instanceof Set;\n}\n","const isObject = value => {\n\tconst type = typeof value;\n\treturn value !== null && (type === 'object' || type === 'function');\n};\n\nconst isEmptyObject = value => isObject(value) && Object.keys(value).length === 0;\n\nconst disallowedKeys = new Set([\n\t'__proto__',\n\t'prototype',\n\t'constructor',\n]);\n\nconst digits = new Set('0123456789');\n\nfunction getPathSegments(path) {\n\tconst parts = [];\n\tlet currentSegment = '';\n\tlet currentPart = 'start';\n\tlet isIgnoring = false;\n\n\tfor (const character of path) {\n\t\tswitch (character) {\n\t\t\tcase '\\\\': {\n\t\t\t\tif (currentPart === 'index') {\n\t\t\t\t\tthrow new Error('Invalid character in an index');\n\t\t\t\t}\n\n\t\t\t\tif (currentPart === 'indexEnd') {\n\t\t\t\t\tthrow new Error('Invalid character after an index');\n\t\t\t\t}\n\n\t\t\t\tif (isIgnoring) {\n\t\t\t\t\tcurrentSegment += character;\n\t\t\t\t}\n\n\t\t\t\tcurrentPart = 'property';\n\t\t\t\tisIgnoring = !isIgnoring;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase '.': {\n\t\t\t\tif (currentPart === 'index') {\n\t\t\t\t\tthrow new Error('Invalid character in an index');\n\t\t\t\t}\n\n\t\t\t\tif (currentPart === 'indexEnd') {\n\t\t\t\t\tcurrentPart = 'property';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (isIgnoring) {\n\t\t\t\t\tisIgnoring = false;\n\t\t\t\t\tcurrentSegment += character;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (disallowedKeys.has(currentSegment)) {\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\n\t\t\t\tparts.push(currentSegment);\n\t\t\t\tcurrentSegment = '';\n\t\t\t\tcurrentPart = 'property';\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase '[': {\n\t\t\t\tif (currentPart === 'index') {\n\t\t\t\t\tthrow new Error('Invalid character in an index');\n\t\t\t\t}\n\n\t\t\t\tif (currentPart === 'indexEnd') {\n\t\t\t\t\tcurrentPart = 'index';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (isIgnoring) {\n\t\t\t\t\tisIgnoring = false;\n\t\t\t\t\tcurrentSegment += character;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (currentPart === 'property') {\n\t\t\t\t\tif (disallowedKeys.has(currentSegment)) {\n\t\t\t\t\t\treturn [];\n\t\t\t\t\t}\n\n\t\t\t\t\tparts.push(currentSegment);\n\t\t\t\t\tcurrentSegment = '';\n\t\t\t\t}\n\n\t\t\t\tcurrentPart = 'index';\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase ']': {\n\t\t\t\tif (currentPart === 'index') {\n\t\t\t\t\tparts.push(Number.parseInt(currentSegment, 10));\n\t\t\t\t\tcurrentSegment = '';\n\t\t\t\t\tcurrentPart = 'indexEnd';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (currentPart === 'indexEnd') {\n\t\t\t\t\tthrow new Error('Invalid character after an index');\n\t\t\t\t}\n\n\t\t\t\t// Falls through\n\t\t\t}\n\n\t\t\tdefault: {\n\t\t\t\tif (currentPart === 'index' && !digits.has(character)) {\n\t\t\t\t\tthrow new Error('Invalid character in an index');\n\t\t\t\t}\n\n\t\t\t\tif (currentPart === 'indexEnd') {\n\t\t\t\t\tthrow new Error('Invalid character after an index');\n\t\t\t\t}\n\n\t\t\t\tif (currentPart === 'start') {\n\t\t\t\t\tcurrentPart = 'property';\n\t\t\t\t}\n\n\t\t\t\tif (isIgnoring) {\n\t\t\t\t\tisIgnoring = false;\n\t\t\t\t\tcurrentSegment += '\\\\';\n\t\t\t\t}\n\n\t\t\t\tcurrentSegment += character;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (isIgnoring) {\n\t\tcurrentSegment += '\\\\';\n\t}\n\n\tswitch (currentPart) {\n\t\tcase 'property': {\n\t\t\tif (disallowedKeys.has(currentSegment)) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tparts.push(currentSegment);\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase 'index': {\n\t\t\tthrow new Error('Index was not closed');\n\t\t}\n\n\t\tcase 'start': {\n\t\t\tparts.push('');\n\n\t\t\tbreak;\n\t\t}\n\t\t// No default\n\t}\n\n\treturn parts;\n}\n\nfunction isStringIndex(object, key) {\n\tif (typeof key !== 'number' && Array.isArray(object)) {\n\t\tconst index = Number.parseInt(key, 10);\n\t\treturn Number.isInteger(index) && object[index] === object[key];\n\t}\n\n\treturn false;\n}\n\nfunction assertNotStringIndex(object, key) {\n\tif (isStringIndex(object, key)) {\n\t\tthrow new Error('Cannot use string index');\n\t}\n}\n\nexport function getProperty(object, path, value) {\n\tif (!isObject(object) || typeof path !== 'string') {\n\t\treturn value === undefined ? object : value;\n\t}\n\n\tconst pathArray = getPathSegments(path);\n\tif (pathArray.length === 0) {\n\t\treturn value;\n\t}\n\n\tfor (let index = 0; index < pathArray.length; index++) {\n\t\tconst key = pathArray[index];\n\n\t\tif (isStringIndex(object, key)) {\n\t\t\tobject = index === pathArray.length - 1 ? undefined : null;\n\t\t} else {\n\t\t\tobject = object[key];\n\t\t}\n\n\t\tif (object === undefined || object === null) {\n\t\t\t// `object` is either `undefined` or `null` so we want to stop the loop, and\n\t\t\t// if this is not the last bit of the path, and\n\t\t\t// if it didn't return `undefined`\n\t\t\t// it would return `null` if `object` is `null`\n\t\t\t// but we want `get({foo: null}, 'foo.bar')` to equal `undefined`, or the supplied value, not `null`\n\t\t\tif (index !== pathArray.length - 1) {\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn object === undefined ? value : object;\n}\n\nexport function setProperty(object, path, value) {\n\tif (!isObject(object) || typeof path !== 'string') {\n\t\treturn object;\n\t}\n\n\tconst root = object;\n\tconst pathArray = getPathSegments(path);\n\n\tfor (let index = 0; index < pathArray.length; index++) {\n\t\tconst key = pathArray[index];\n\n\t\tassertNotStringIndex(object, key);\n\n\t\tif (index === pathArray.length - 1) {\n\t\t\tobject[key] = value;\n\t\t} else if (!isObject(object[key])) {\n\t\t\tobject[key] = typeof pathArray[index + 1] === 'number' ? [] : {};\n\t\t}\n\n\t\tobject = object[key];\n\t}\n\n\treturn root;\n}\n\nexport function deleteProperty(object, path) {\n\tif (!isObject(object) || typeof path !== 'string') {\n\t\treturn false;\n\t}\n\n\tconst pathArray = getPathSegments(path);\n\n\tfor (let index = 0; index < pathArray.length; index++) {\n\t\tconst key = pathArray[index];\n\n\t\tassertNotStringIndex(object, key);\n\n\t\tif (index === pathArray.length - 1) {\n\t\t\tdelete object[key];\n\t\t\treturn true;\n\t\t}\n\n\t\tobject = object[key];\n\n\t\tif (!isObject(object)) {\n\t\t\treturn false;\n\t\t}\n\t}\n}\n\nexport function hasProperty(object, path) {\n\tif (!isObject(object) || typeof path !== 'string') {\n\t\treturn false;\n\t}\n\n\tconst pathArray = getPathSegments(path);\n\tif (pathArray.length === 0) {\n\t\treturn false;\n\t}\n\n\tfor (const key of pathArray) {\n\t\tif (!isObject(object) || !(key in object) || isStringIndex(object, key)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tobject = object[key];\n\t}\n\n\treturn true;\n}\n\n// TODO: Backslashes with no effect should not be escaped\nexport function escapePath(path) {\n\tif (typeof path !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\treturn path.replaceAll(/[\\\\.[]/g, '\\\\$&');\n}\n\n// The keys returned by Object.entries() for arrays are strings\nfunction entries(value) {\n\tconst result = Object.entries(value);\n\tif (Array.isArray(value)) {\n\t\treturn result.map(([key, value]) => [Number(key), value]);\n\t}\n\n\treturn result;\n}\n\nfunction stringifyPath(pathSegments) {\n\tlet result = '';\n\n\tfor (let [index, segment] of entries(pathSegments)) {\n\t\tif (typeof segment === 'number') {\n\t\t\tresult += `[${segment}]`;\n\t\t} else {\n\t\t\tsegment = escapePath(segment);\n\t\t\tresult += index === 0 ? segment : `.${segment}`;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nfunction * deepKeysIterator(object, currentPath = []) {\n\tif (!isObject(object) || isEmptyObject(object)) {\n\t\tif (currentPath.length > 0) {\n\t\t\tyield stringifyPath(currentPath);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tfor (const [key, value] of entries(object)) {\n\t\tyield * deepKeysIterator(value, [...currentPath, key]);\n\t}\n}\n\nexport function deepKeys(object) {\n\treturn [...deepKeysIterator(object)];\n}\n","import { getProperty } from \"dot-prop\";\nimport { setClasses } from \"./classes\";\n\nexport function bind(element, name, value) {\n  switch (name) {\n    case \"class\":\n      bindClasses(element, value);\n      break;\n\n    case \"all\":\n      bindAll(element, value);\n      break;\n\n    case \"text\":\n      bindText(element, value);\n      break;\n\n    case \"html\":\n      bindHTML(element, value);\n      break;\n\n    case \"checked\":\n    case \"selected\":\n      bindAttributeAndProperty(element, name, value);\n      break;\n\n    default:\n      bindAttribute(element, name, value);\n      break;\n  }\n}\n\nfunction bindClasses(element, value) {\n  if (element.__value_bindings_undo_classes) element.__value_bindings_undo_classes();\n  element.__value_bindings_undo_classes = setClasses(element, value);\n}\n\nfunction bindText(element, value) {\n  element.textContent = value;\n}\n\nfunction bindHTML(element, value) {\n  element.innerHTML = value;\n}\n\nfunction bindAttribute(el, name, value) {\n  if ([null, undefined, false].includes(value) && attributeShouldntBePreservedIfFalsy(name)) {\n    el.removeAttribute(name);\n  } else {\n    if (isBooleanAttr(name)) value = name;\n    setIfChanged(el, name, value);\n  }\n}\n\nfunction bindAll(element, obj) {\n  Object.keys(obj).forEach((name) => bind(element, name, getProperty(obj, name)));\n}\n\nfunction bindAttributeAndProperty(el, name, value) {\n  bindAttribute(el, name, value);\n  setPropertyIfChanged(el, name, value);\n}\n\nfunction setIfChanged(el, attrName, value) {\n  if (el.getAttribute(attrName) != value) {\n    el.setAttribute(attrName, value);\n  }\n}\n\nfunction setPropertyIfChanged(el, propName, value) {\n  if (el[propName] !== value) {\n    el[propName] = value;\n  }\n}\n\n// As per HTML spec table https://html.spec.whatwg.org/multipage/indices.html#attributes-3:boolean-attribute\nconst booleanAttributes = new Set([\n  \"allowfullscreen\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"inert\",\n  \"ismap\",\n  \"itemscope\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\",\n]);\n\nfunction isBooleanAttr(attrName) {\n  return booleanAttributes.has(attrName);\n}\n\nfunction attributeShouldntBePreservedIfFalsy(name) {\n  return ![\"aria-pressed\", \"aria-checked\", \"aria-expanded\", \"aria-selected\"].includes(name);\n}\n","export function setClasses(el, value) {\n  if (Array.isArray(value)) {\n    return setClassesFromString(el, value.join(\" \"));\n  } else if (typeof value === \"object\" && value !== null) {\n    return setClassesFromObject(el, value);\n  }\n  return setClassesFromString(el, value);\n}\n\nfunction setClassesFromString(el, classString) {\n  let missingClasses = (classString) =>\n    classString\n      .split(\" \")\n      .filter((i) => !el.classList.contains(i))\n      .filter(Boolean);\n\n  let classes = missingClasses(classString);\n  el.classList.add(...classes);\n\n  return () => el.classList.remove(...classes);\n}\n\nfunction setClassesFromObject(el, classObject) {\n  let split = (classString) => classString.split(\" \").filter(Boolean);\n\n  let forAdd = Object.entries(classObject)\n    .flatMap(([classString, bool]) => (bool ? split(classString) : false))\n    .filter(Boolean);\n  let forRemove = Object.entries(classObject)\n    .flatMap(([classString, bool]) => (!bool ? split(classString) : false))\n    .filter(Boolean);\n\n  let added = [];\n  let removed = [];\n\n  forRemove.forEach((i) => {\n    if (el.classList.contains(i)) {\n      el.classList.remove(i);\n      removed.push(i);\n    }\n  });\n\n  forAdd.forEach((i) => {\n    if (!el.classList.contains(i)) {\n      el.classList.add(i);\n      added.push(i);\n    }\n  });\n\n  return () => {\n    removed.forEach((i) => el.classList.add(i));\n    added.forEach((i) => el.classList.remove(i));\n  };\n}\n"],"names":[],"version":3,"file":"main.js.map","sourceRoot":"../"}